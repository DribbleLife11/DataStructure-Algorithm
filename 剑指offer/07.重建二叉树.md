# 剑指Offer 07.重建二叉树

### 题目描述：

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

前序遍历 preorder = [3,9,20,15,7]

中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

<pre>    3
   / \
  9  20
    /  \
   15   7</pre>

限制：

0 <= 节点个数 <= 5000

### 解题思路：

1、递归

首先，根据前序遍历在中序遍历的数组种找出根节点，这样就可以找处左右子树的节点并计算出左子树的节点个数和右子树的节点个数。



然后，通过中序遍历中得出的左右子树节点数量在前序遍历中找到左右子树的分界，因此可以进一步得到左子树和右子树的前序遍历和中序遍历，通过递归的方式，重建左子树和右子树，最后重建出整个二叉树。





维护一个Map，将中序遍历的节点和其对应的下标放入Map中。定义前序遍历节点的开始下标为preorderStart，结束下标为preorderEnd，当preorderStart>preorderEnd时说明树中没有节点，返回null；当preorderStart=preorderEnd时说明树中只有一个节点，返回这个节点即可。当preorderStart<preorderEnd时，说明树种有多个节点，根据前面分析的通过递归对二叉树进行重建。

> 使用一个 Map 存储中序遍历的每个元素及其对应的下标，目的是为了快速获得一个元素在中序遍历中的位置。调用递归方法，对于前序遍历和中序遍历，下标范围都是从 0 到 n-1，其中 n 是二叉树节点个数。
>
> 递归方法的基准情形有两个：判断前序遍历的下标范围的开始和结束，若开始大于结束，则当前的二叉树中没有节点，返回空值 null。若开始等于结束，则当前的二叉树中恰好有一个节点，根据节点值创建该节点作为根节点并返回。
>
> 若开始小于结束，则当前的二叉树中有多个节点。在中序遍历中得到根节点的位置，从而得到左子树和右子树各自的下标范围和节点数量，知道节点数量后，在前序遍历中即可得到左子树和右子树各自的下标范围，然后递归重建左子树和右子树，并将左右子树的根节点分别作为当前根节点的左右子节点。
>
> ——来自力扣题解。

代码：

~~~java
/*
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder == null || preorder.length == 0) {
            return null;
        }
        int len = preorder.length;
        Map<Integer,Integer> indexMap = new HashMap<>();
        for (int i = 0; i < len; i++) {
            indexMap.put(inorder[i], i);
        }
        TreeNode root = buildTree(preorder, 0, len - 1, inorder, 0, len - 1, indexMap);

        return root;
    }

    public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map<Integer,Integer> indexMap) {
        if (preorderStart > preorderEnd) {
            return null;
        }

        int rootVal = preorder[preorderStart];
        TreeNode root = new TreeNode(rootVal);
        if (preorderStart == preorderEnd) {
            return root;
        } else {
            int rootIndex = indexMap.get(rootVal);	//获取根节点在中序遍历数组中的下标
            int leftNodes = rootIndex - inorderStart;	//左子树节点个数
            int rightNodes = inorderEnd - rootIndex;	//右子树节点个数
            TreeNode leftSubTree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);
            TreeNode rightSubTree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);
            root.left = leftSubTree;
            root.right = rightSubTree; 
        }
        return root;
    }
}
~~~

**复杂度分析**

- 时间复杂度：O(n)*O*(*n*)。对于每个节点都有创建过程以及根据左右子树重建过程。
- 空间复杂度：O(n)*O*(*n*)。存储整棵树的开销。

<hr> </hr>

2、迭代


